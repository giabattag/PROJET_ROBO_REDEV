function [thrust, moments] = droneControlSMC(u1, s, omega, control_type_param, drone_params, DroneID, g)
%droneControlSMC is the SMC function used to control the drone in
%ErskineSingleDrone.slx
%
%   The modes which may be selected are:
%     1: Position/Yaw - F_W ONLY ONE ACTIVE
%     2: Velocity/Yawrate - F_B
%     3: Acceleration/Yawrate - F_B
%     4: Thrust/Attitude - reference quaternion - F_W
%     5: Thrust/BodyRate - F_B
%     6: Thrust/Moments - F_B
%   Note that F_W (world) and F_B (body) indicate the frame of reference
%   for the input.
%
% u: the 4 (5 in the case of thrust/attitude mode) input to the controller
% p: the current measured drone position in F_W
% v: the current measured drone velocity in F_B
% q: the current attitude estimate of the drone in F_W
% omega: the current measured angular velocity of the drone in F_B
%
% control_type_parameter: integer used to select the control mode.
% drone_params: array of structures (see setDefaulDroneParams.m) containing
% the mechanical and control parameters of each drone.
% DroneID: Integer used to select which drone in the drone_params arrays.
% g: Magnitude of gravitational acceleration (assumed to be in the -z_W
% direction).
%
% The position control is a PD controller. The velocity, yawrate, and body rate 
% are P controllers. Translational control has saturated thrust along the
% desired acceleration vector (see documentation of saturateThrust.m)
%
% The attitude controls are PD based, and combine aspects of: 
% Brescianini D, Hehn M, and D'Andrea R. "Nonlinear Quadrocopter Attitude 
% Control Technical Report", ETHZ 2013. and 
% Fresk E, and Nikolakopoulos G. "Full Quaternion Based Attitude Control 
% for a Quadrotor", European Control Conference, 2013.

% m = drone_params(DroneID).mechanical.m;
% kp_attitude = drone_params(DroneID).control.attitude.kp;
% kd_attitude = drone_params(DroneID).control.attitude.kd;
I = drone_params(DroneID).mechanical.I;

% attitude control
dphi = omega(1);
dtht = omega(2);
dpsi = omega(3);
Ix = I(1,1);
Iy = I(2,2);
Iz = I(3,3);
s1=s(1);
s2=s(2);
s3=s(3);
tuning_parameter = 100;

ism = [(Iy-Iz)/Ix*dpsi*dtht;
        (Iz-Ix)/Iy*dpsi*dphi;
        (Ix-Iy)/Iz*dphi*dtht];
k1=55;
k2=55;
k3=55;
asm = ism + tuning_parameter*[dphi; dtht; dpsi];
K = diag([k1, k2, k3]);

beta = inv(I);

u2  = beta \ (-asm - K*sign([s1; s2; s3]));

%     U = [u1; u2];

%     Mu =...
%     [kt      kt       kt       kt;
%      -l/2*kt   l/2*kt     -l/2*kt    l/2*kt;
%      l/2*kt    -l/2*kt    -l/2*kt    l/2*kt;
%      kd     kd      -kd     -kd];
% 
%     Mu = [Mu(:,3) Mu(:,1) Mu(:,4) Mu(:,2)];
kt = drone_params(DroneID).motors.kt_prop;
kd = drone_params(DroneID).motors.kd_prop;
Pu = ...
[kt     kt      kt      kt;
 -kt/2      kt/2     -kt/2       kt/2;
 kt/2      -kt/2     -kt/2       kt/2;
 kd     kd     -kd      -kd];

%     Pu = [Pu(:,2) Pu(:,4) Pu(:,1) Pu(:,3)];

Mu = drone_params(DroneID).control.allocation_matrix_u;

omega_props2 = Pu \ [u1; u2];
FM = Mu*omega_props2;

thrust = FM(1);
moments = FM(2:4);

